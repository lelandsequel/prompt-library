#!/usr/bin/env node
/**
 * PromptOS Learning Loop — Analyzer
 * 
 * Reads .telemetry/promptos-usage.jsonl, identifies prompts with >20% failure rate,
 * and generates improvement proposals in learn/proposals/<prompt_id>-proposal.yaml
 */
'use strict';

const fs = require('fs');
const path = require('path');

const BASE_DIR = path.resolve(__dirname, '..');
const PROPOSALS_DIR = path.join(__dirname, 'proposals');

function loadYAML(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  try { return require('js-yaml').load(content); }
  catch (_) { return require('yaml').parse(content); }
}

function analyze() {
  const { readAll } = require('../analytics/logger.js');
  const entries = readAll();

  if (entries.length === 0) {
    console.log('No telemetry data found. Nothing to analyze.');
    return [];
  }

  // Group by prompt_id
  const byPrompt = {};
  for (const e of entries) {
    if (!byPrompt[e.prompt_id]) byPrompt[e.prompt_id] = { runs: 0, failures: 0, errors: [] };
    byPrompt[e.prompt_id].runs++;
    if (!e.success) {
      byPrompt[e.prompt_id].failures++;
      if (e.error) byPrompt[e.prompt_id].errors.push(e.error);
    }
  }

  const proposals = [];

  for (const [prompt_id, stats] of Object.entries(byPrompt)) {
    const failRate = stats.failures / stats.runs;
    if (failRate > 0.2) {
      console.log(`[analyzer] ${prompt_id}: ${(failRate * 100).toFixed(1)}% failure rate — generating proposal`);
      const proposal = generateProposal(prompt_id, stats);
      proposals.push(proposal);
      writeProposal(prompt_id, proposal);
    }
  }

  if (proposals.length === 0) {
    console.log('All prompts are performing well (failure rate ≤ 20%). No proposals needed.');
  }

  return proposals;
}

function generateProposal(prompt_id, stats) {
  const failRate = ((stats.failures / stats.runs) * 100).toFixed(1);
  const commonErrors = [...new Set(stats.errors)].slice(0, 5);

  // Try to load current spec for context
  let currentSpec = null;
  try {
    const registry = JSON.parse(fs.readFileSync(path.join(BASE_DIR, 'registry', 'index.json'), 'utf8'));
    const entry = registry.prompts.find(p => p.id === prompt_id);
    if (entry) {
      currentSpec = loadYAML(path.join(BASE_DIR, entry.file));
    }
  } catch (_) {}

  const proposal = {
    prompt_id,
    generated_at: new Date().toISOString(),
    analysis: {
      total_runs: stats.runs,
      failures: stats.failures,
      failure_rate: `${failRate}%`,
      common_errors: commonErrors
    },
    current_version: currentSpec?.version || 'unknown',
    suggested_changes: []
  };

  // Generate generic suggestions based on error patterns
  if (commonErrors.some(e => /timeout/i.test(e))) {
    proposal.suggested_changes.push({
      type: 'reduce_complexity',
      description: 'Consider breaking this prompt into smaller sub-prompts to reduce timeout risk'
    });
  }
  if (commonErrors.some(e => /validation/i.test(e))) {
    proposal.suggested_changes.push({
      type: 'improve_output_format',
      description: 'Add explicit output format instructions to ensure structured response'
    });
  }
  if (commonErrors.some(e => /rbac|permission/i.test(e))) {
    proposal.suggested_changes.push({
      type: 'rbac_review',
      description: 'Review RBAC permissions — users are being denied access frequently'
    });
  }
  if (commonErrors.some(e => /policy/i.test(e))) {
    proposal.suggested_changes.push({
      type: 'policy_review',
      description: 'Review policy rules — this prompt is frequently blocked by policy engine'
    });
  }

  // Always suggest adding examples if failure rate is high
  proposal.suggested_changes.push({
    type: 'add_examples',
    description: `Add more diverse examples to improve model understanding (current failure rate: ${failRate}%)`
  });

  proposal.suggested_changes.push({
    type: 'clarify_instructions',
    description: 'Rewrite instructions to be more explicit about expected output format'
  });

  return proposal;
}

function writeProposal(prompt_id, proposal) {
  fs.mkdirSync(PROPOSALS_DIR, { recursive: true });
  const outPath = path.join(PROPOSALS_DIR, `${prompt_id}-proposal.yaml`);

  let content = `# PromptOS Improvement Proposal\n`;
  content += `# Auto-generated by learn/analyzer.js\n`;
  content += `# ${new Date().toISOString()}\n\n`;
  content += `prompt_id: ${proposal.prompt_id}\n`;
  content += `generated_at: "${proposal.generated_at}"\n`;
  content += `current_version: "${proposal.current_version}"\n\n`;
  content += `analysis:\n`;
  content += `  total_runs: ${proposal.analysis.total_runs}\n`;
  content += `  failures: ${proposal.analysis.failures}\n`;
  content += `  failure_rate: "${proposal.analysis.failure_rate}"\n`;
  if (proposal.analysis.common_errors.length > 0) {
    content += `  common_errors:\n`;
    for (const e of proposal.analysis.common_errors) {
      content += `    - "${e.replace(/"/g, '\\"')}"\n`;
    }
  }
  content += `\nsuggested_changes:\n`;
  for (const c of proposal.suggested_changes) {
    content += `  - type: ${c.type}\n`;
    content += `    description: "${c.description}"\n`;
  }

  fs.writeFileSync(outPath, content, 'utf8');
  console.log(`  → Proposal written: ${outPath}`);
}

module.exports = { analyze, generateProposal };

if (require.main === module) {
  analyze();
}
